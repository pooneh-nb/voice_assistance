#!/usr/bin/python

"""
Script used to extract only the needed information from JSON packet traces generated by
tshark from PCAPNG format
"""

# This file is a part of OVRseen <https://athinagroup.eng.uci.edu/projects/ovrseen/>.
# Copyright (c) 2021 UCI Networking Group.
#
# This file incorporates content from NoMoATS <http://athinagroup.eng.uci.edu/projects/nomoads/>.
# Copyright (C) 2019 Anastasia Shuba.
#
# OVRseen is dual licensed under the MIT License and the GNU General Public
# License version 3 (GPLv3). This file is covered by the GPLv3. If this file
# get used, GPLv3 applies to all of OVRseen.
#
# See the LICENSE.md file along with OVRseen for more details.

import os, sys
import json
import uuid
import argparse

from collections import OrderedDict

from pii_helper import PIIHelper
import json_keys

# Prepare PII helper
pii_helper = PIIHelper(json_keys.PII_VALUES, json_keys.LOCATION_PII, should_redact=True)

# set of tuples (src port, dst IP) of decrypted connections
decrypted_tuples = set()


def make_unique(key, dct):
    counter = 0
    unique_key = key

    while unique_key in dct:
        counter += 1
        unique_key = key + "_" + str(counter)
    return unique_key


def parse_object_pairs(pairs):
    dct = OrderedDict()
    for key, value in pairs:
        if key in dct:
            key = make_unique(key, dct)
        dct[key] = value

    return dct


def get_tcp_stream_number(pkt):
    '''
    Extract the TCP stream id/number assigned to this packet by tshark.
    :param pkt: A packet in tshark json format.
    :return: The TCP stream id/number assigned by tshark to this packet, or None if the value is not present in the
             packet, e.g., the packet is not a TCP segment.
    '''
    layers = pkt[json_keys.source][json_keys.layers]
    if json_keys.tcp not in layers:
        return None
    tcp_section = layers[json_keys.tcp]
    if json_keys.tcpstream not in tcp_section:
        return None
    return int(tcp_section[json_keys.tcpstream])


def extract_http_pkt(layers, frame_num, include_http_body=False):
    '''
    Extract HTTP information from tshark json to NoMoAds json.
    :param layers: a packet data from the _source.layers structure in tshark json format.
    :param frame_num: a string containing the frame number (for std.out warnings in case something unexpected happens)
    :return: A map that contains the interesting HTTP data
    '''

    # Go through all HTTP fields and extract the ones that are needed
    http_data = layers[json_keys.http]
    new_packet = {}

    # Prepare container for HTTP headers
    if json_keys.headers not in new_packet:
        new_packet[json_keys.headers] = {}

    # Go through other keys of interest
    for http_key in http_data:
        http_value = http_data[http_key]

        if http_key.startswith(json_keys.http_req_line):
            header_line = http_value.split(":", 1)
            if len(header_line) != 2:
                print("WARNING: could not parse header '" + str(header_line) + "'"
                      + frame_num)
                continue

            # Use lower case for header keys to stay consistent with our other data
            header_key = header_line[0].lower()

            # Remove the trailing carriage return
            header_val = header_line[1].strip()

            # Save the header key-value pair
            new_packet[json_keys.headers][header_key] = header_val

            # If this is the host header, we also save it to the main object
            if header_key == json_keys.host:
                new_packet[json_keys.host] = header_val

        if json_keys.http_req_method in http_value:
            new_packet[json_keys.method] = http_value[json_keys.http_req_method]
        if json_keys.http_req_uri in http_value:
            new_packet[json_keys.uri] = http_value[json_keys.http_req_uri]

    # Note that packet was http
    new_packet[json_keys.protocol] = json_keys.http

    if len(new_packet[json_keys.headers].keys()) == 0:
        print("WARNING: packet has no header: ", str(http_data))

    # Save PII
    pii_found = []

    # If there is a body, check it for PII. Since we don't save body data, we don't care about redacting it
    if json_keys.http_body in http_data:
        redacted_http_body, pii_found_in_body = pii_helper.get_pii_from_str(http_data[json_keys.http_body])
        if include_http_body:
            new_packet[json_keys.http_body] = redacted_http_body
            new_packet[json_keys.http_body].strip()
        pii_found += pii_found_in_body

    # Find PII in the json data that we will share, make note of them, and redact them
    redacted_packet, pii_found_in_headers = pii_helper.get_pii_from_data(new_packet)
    pii_found += pii_found_in_headers

    # Save the PII
    redacted_packet[json_keys.pii_label] = pii_found

    return redacted_packet


def extract_tls_pkt(layers):
    '''
    Extract TLS information from tshark json to NoMoAds json.
    :param layers: a packet data from the _source.layers structure in tshark json format.
    :return: A map that contains the interesting TLS data
    '''

    ssl_layer = layers[json_keys.ssl]
    ssl_record_key = json_keys.ssl + ".record"
    ssl_handshake_key = json_keys.ssl + ".handshake"
    if ssl_record_key not in ssl_layer or ssl_handshake_key not in ssl_layer[ssl_record_key]:
        return None

    handshake = ssl_layer[ssl_record_key][ssl_handshake_key]
    for key in handshake:
        if key.startswith("Extension: server_name"):
            # Carries the server name extension, see if we can find SNI
            srv_name_ext = handshake[key]
            # SNI is an object with properties
            sni_ext_obj_key = "Server Name Indication extension"
            if sni_ext_obj_key not in srv_name_ext:
                # SNI not present
                return None
            sni_ext_obj = srv_name_ext[sni_ext_obj_key]
            srv_name_key = ssl_handshake_key + ".extensions_server_name"
            if srv_name_key not in sni_ext_obj:
                return None
            # Found SNI, so create a new packet and return it to caller
            new_packet = {}
            # We put the value of the SNI in the host field as that is the host the client is talking to.
            new_packet[json_keys.host] = sni_ext_obj[srv_name_key]
            # Note that packet was TLS
            new_packet[json_keys.protocol] = json_keys.ssl
            return new_packet

    # Not a Client Hello handshake packet, or a handshake packet w/o SNI.
    return None


def extract_other_pkt(layers, frame_num, include_http_body=False):
    '''
    Extract JSON-structured information in other packets from tshark json to NoMoAds json.
    :param layers: a packet data from the _source.layers structure in tshark json format.
    :param frame_num: a string containing the frame number (for std.out warnings in case something unexpected happens)
    :return: A map that contains the interesting JSON data
    '''
    # Get what we need from the packet
    new_packet = {}
    # Save PII
    pii_found = []

    # Check if this is a websocket packet
    if json_keys.websocket in layers and json_keys.websocketdata in layers:
        # Note that packet was websocket
        new_packet[json_keys.protocol] = json_keys.websocket
        # Extract PII from data
        json_data = json.dumps(layers[json_keys.websocketdata])
    else:
        # Note that packet was irc
        new_packet[json_keys.protocol] = json_keys.irc
        # Extract PII from data
        json_data = json.dumps(layers[json_keys.irc])

    # Find PII values/keys
    redacted_websocket_body, pii_found_in_body = pii_helper.get_pii_from_str(json_data)
    if include_http_body:
        new_packet[json_keys.http_body] = redacted_websocket_body
        new_packet[json_keys.http_body].strip()
    pii_found += pii_found_in_body
    # Save the PII
    new_packet[json_keys.pii_label] = pii_found

    return new_packet


def extract_from_tshark(full_path, data, is_decrypted, include_http_body=False):
    with open(full_path, "rb") as jf:
        # Since certain json 'keys' appear multiple times in our data, we have to make them
        # unique first (we can't use regular json.load() or we lose some data points). From:
        # https://stackoverflow.com/questions/29321677/python-json-parser-allow-duplicate-keys
        decoder = json.JSONDecoder(object_pairs_hook=parse_object_pairs)
        pcap_data = decoder.decode(jf.read().decode(errors='ignore'))

        for packet in pcap_data:
            layers = packet[json_keys.source][json_keys.layers]

            # All captured traffic should have a frame + frame number, but check anyway
            frame_num = " Frame: "
            if json_keys.frame not in layers or json_keys.frame_num not in layers[json_keys.frame]:
                print("WARNING: could not find frame number! Using -1...")
                frame_num = frame_num + "-1"
            else:
                # Save frame number for error-reporting
                frame_num = frame_num + layers[json_keys.frame][json_keys.frame_num]

            # All captured traffic should be IP, but check anyway
            if not json_keys.ip in layers:
                print("WARNING: Non-IP traffic detected!" + frame_num)
                continue

            # For now we only care about outgoing traffic
            src_ip = layers[json_keys.ip][json_keys.ip + ".src"]
            dst_ip = layers[json_keys.ip][json_keys.ip + ".dst"]
            if src_ip != json_keys.ANTMONITOR_SRC_IP:
                continue

            # For now, only care about TCP traffic
            if not json_keys.tcp in layers:
                continue

            src_port = int(layers[json_keys.tcp][json_keys.tcp + ".srcport"])
            dst_port = int(layers[json_keys.tcp][json_keys.tcp + ".dstport"])

            # Perform initialization of new_packet in application layer protocol data extraction functions:
            # Attempt to extract application layer protocol information for each of the protocols that we are interested
            # in until we successfully hit the protocol (or declare that the packet is not interesting if no match).
            new_packet = None

            # Check if HTTP first
            if json_keys.http in layers:
                new_packet = extract_http_pkt(layers, frame_num, include_http_body=include_http_body)
                # Keep track of decrypted connections by source port and destination IP to avoid double-counting
                if is_decrypted:
                    decrypted_tuples.add((src_port, dst_ip))
            # Not HTTP, so try TLS as those may carry the hostname of the server in the SNI.
            # We skip SNI for flows which were decrypted and where we got the host name from HTTP headers
            # NOTE: we still save SNI for non-HTTP flows that were decrypted as those do not contain a host field
            elif json_keys.ssl in layers and (src_port, dst_ip) not in decrypted_tuples:
                new_packet = extract_tls_pkt(layers)
            else:
                # Packet not HTTP, so it's not interesting to us.
                # Some TLS packets still go here, so skip these as well.
                if not json_keys.ssl in layers:
                    # We are interested in websocket and irc packets.
                    if json_keys.websocket in layers and json_keys.websocketdata in layers:
                        new_packet = extract_other_pkt(layers, frame_num, include_http_body=include_http_body)
                    if json_keys.irc in layers:
                        new_packet = extract_other_pkt(layers, frame_num, include_http_body=include_http_body)
                else:
                    continue

            if new_packet is None:
                continue  # e.g., skip TLS packet with no SNI info

            # Fill our new JSON packet with TCP/IP info and other common info
            new_packet[json_keys.src_ip] = src_ip
            new_packet[json_keys.dst_ip] = dst_ip
            new_packet[json_keys.dst_port] = dst_port

            # Extract the tcp stream id/number, if any
            tcp_stream_id = get_tcp_stream_number(packet)
            if tcp_stream_id is not None:
                new_packet[json_keys.tcpstream] = tcp_stream_id

            # Extract and parse the packet comment
            if (json_keys.pkt_comment not in layers or
                    json_keys.frame_comment not in layers[json_keys.pkt_comment]):
                print("WARNING: no packet comment found!" + frame_num)
                continue

            # Extract package info from comment
            comment = layers[json_keys.pkt_comment][json_keys.frame_comment]
            comment_data = json.loads(comment)
            new_packet[json_keys.package_name] = comment_data[json_keys.package_name]
            new_packet[json_keys.version] = comment_data[json_keys.version]

            # Extract timestamp
            if json_keys.frame_ts not in layers[json_keys.frame]:
                print("WARNING: could not find timestamp!" + frame_num)
                continue

            new_packet["ts"] = layers[json_keys.frame][json_keys.frame_ts]

            # Create a unique key for each packet to keep consistent with ReCon
            # Also good in case packets end up in different files
            data[str(uuid.uuid4())] = new_packet


def write_data(data, file_out, permission):
    # Write the new data
    with open(file_out, permission) as jf:
        # print json.dumps(data, sort_keys=True, indent=4)
        jf.seek(0)
        jf.write(json.dumps(data, sort_keys=True, indent=4))
        jf.truncate()


def extract(tshark_file_enc, tshark_file_dec, out_file, **kwargs):
    """
    Extracts only the needed information from provided JSON packet traces and labels them
    :param tshark_file: JSON file containing data extracted via tshark
    :param out_file: File to write results to
    :return: True on success, False on failure
    """

    if not (os.path.isfile(tshark_file_enc) or os.path.isfile(tshark_file_dec)):
        print("ERROR: invalid argument")
        return False

    # Prepare new data structure for re-formatted JSON storage
    data = {}

    # Extract decrypted data first to know which connections were successfully decrypted
    extract_from_tshark(tshark_file_dec, data, True, **kwargs)

    # Extract encrypted data next
    extract_from_tshark(tshark_file_enc, data, False, **kwargs)

    write_data(data, out_file, "w")

    return True


if __name__ == '__main__':
    ap = argparse.ArgumentParser(description="Converts tshark JSON output into NoMoAds JSON format")
    ap.add_argument('--enc_file', required=True,
                    help='Encrypted pcap')
    ap.add_argument('--out_file', required=True,
                    help='Output file')
    ap.add_argument('--include_http_body', action="store_true",
                    help='Whether to include http body')
    args = ap.parse_args()

    extract(args.enc_file, args.dec_file, args.out_file, include_http_body=args.include_http_body)
